import ctypes
import sys
import time
import os
from common.logger import logger
from common.ToolsKit import ToolsKit
from common.mytSelector import mytSelector
import json


CB_FUNC = ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int, ctypes.POINTER(ctypes.c_void_p), ctypes.c_int)
AUDIO_CB_FUNC = ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p), ctypes.c_int)


@CB_FUNC
def video_cb(rot, data, len):
    # åœ¨è¿™é‡Œå¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
    buf = ctypes.cast(data, ctypes.POINTER(ctypes.c_ubyte * len)).contents
    bin_buf = bytearray(buf)
    # æ­¤æ¬¡ä¸ºè§£æå‡ºæ¥çš„h264æµæ•°æ®  å¯ä»¥åšç›¸åº”çš„æ“ä½œå¤„ç† è¿™é‡Œåªæ˜¯ç»™å‡ºä¿å­˜åˆ°æ–‡ä»¶çš„ç¤ºä¾‹
    with open("video.raw", 'ab') as f:
        f.write(bin_buf)
    # print("video",rot, data, len)
    # res = ctypes.string_at(data, len)
    # g_data += res
    # if time.time() - start < 10:
    #     with open("video.raw", 'ab+') as f:
    #         f.write(res)
# cb = CB_FUNC(cb1)


#æ’­æ”¾acc æ–‡ä»¶  å°±æ·»åŠ å¤´  å¦‚æœç›´æ¥è§£ç  å°±ä¸éœ€è¦æ·»åŠ adts å¤´
def add_adts_header(aac_data):
    # ADTS å¤´éƒ¨æ ¼å¼
    adts = [0] * 7
    # ADTS å¤´éƒ¨è¯¦ç»†å‚æ•°
    profile = 1  # AAC LC (Low Complexity) profile is 1
    freq_idx = 4            #44100
    chan_cfg = 2            #channels =2 
    # è®¡ç®—å¸§é•¿åº¦
    frame_length = len(aac_data) 
    # æ„é€  ADTS å¤´éƒ¨
    adts[0] = 0xFF  # åŒæ­¥å­—
    adts[1] = 0xF1  # åŒæ­¥å­—ï¼ŒMPEG-2 Layer (0 for MPEG-4)ï¼Œä¿æŠ¤æ ‡å¿—
    adts[2] = (profile << 6) + (freq_idx << 2) + (chan_cfg >> 2)
    adts[3] = ((chan_cfg & 3) << 6) + ((frame_length + 7) >> 11)
    adts[4] = ((frame_length + 7) & 0x7FF) >> 3
    adts[5] = (((frame_length + 7) & 7) << 5) + 0x1F
    adts[6] = 0xFC  # Number of raw data blocks in frame
    # åˆå¹¶ ADTS å¤´éƒ¨å’Œ AAC æ•°æ®
    adts_aac_data = bytearray(adts) + aac_data
    return adts_aac_data

@AUDIO_CB_FUNC
def audio_cb(data, len):
    
    if len == 2:
        #è¯¥2ä¸ªå­—èŠ‚ä¸ºmyt æ·»åŠ çš„æ ‡è®° ä¸ç”¨å¤„ç† 
        #print(f"audio_cb :len={len}")
        pass
    else:
        buf = ctypes.cast(data, ctypes.POINTER(ctypes.c_ubyte * len)).contents
        bin_buf = bytearray(buf)

        #æ’­æ”¾acc æ–‡ä»¶  å°±æ·»åŠ å¤´  å¦‚æœç›´æ¥è§£ç  å°±ä¸éœ€è¦æ·»åŠ adts å¤´
        adts_aac_data = add_adts_header(bin_buf)
        # æ­¤æ¬¡ä¸ºè§£æå‡ºæ¥çš„aac åŸå§‹éŸ³é¢‘æµæ•°æ®  å¯ä»¥åšç›¸åº”çš„æ“ä½œå¤„ç† è¿™é‡Œåªæ˜¯ç»™å‡ºä¿å­˜åˆ°æ–‡ä»¶çš„ç¤ºä¾‹
        with open("audio.aac", 'ab') as f:
            f.write(adts_aac_data)

# myt rpc  lib
#   add node oper 2024.1.31
class MytRpc(object):
    # _lib_PATH = "/home/zwj/tiktok/lib/libmytrpc.so"
    # _handle = 0
    def __init__(self) -> None:

        try:
            # PyInstaller creates a temp folder and stores path in _MEIPASS
            # This is the base path when running as a bundled app
            base_path = sys._MEIPASS
            # For debugging, let's see what ToolsKit().GetRootPath() (os.getcwd()) was
            tools_root_path_debug = ToolsKit().GetRootPath() 
        except AttributeError:
            # Not bundled, running in development (e.g., python main.py)
            # Assume 'lib' is relative to the main script's directory (e.g., backend/main.py and backend/lib/)
            base_path = os.path.abspath(os.path.dirname(sys.argv[0]))
            tools_root_path_debug = ToolsKit().GetRootPath() # or base_path, depending on dev CWD

        if sys.platform == "linux":
            self._lib_PATH = os.path.join(base_path, "lib", "libmytrpc.so")
        else:
            self._lib_PATH = os.path.join(base_path, "lib", "libmytrpc.dll")

        # ---- START MYTRPC DEBUG PRINTS (DISABLED FOR CLEANER LOGS) ----
        # print(f"[MYTRPC DEBUG] Effective base_path for resources (sys._MEIPASS or dev path): {base_path}")
        # print(f"[MYTRPC DEBUG] (For comparison) common.ToolsKit().GetRootPath() (os.getcwd()) was: {tools_root_path_debug}")
        # print(f"[MYTRPC DEBUG] self._lib_PATH (using new logic) resolved to: {self._lib_PATH}")
        # print(f"[MYTRPC DEBUG] Does self._lib_PATH (using new logic) exist? {os.path.exists(self._lib_PATH)}")
        # ---- END MYTRPC DEBUG PRINTS ----

        self._handle = 0
        # if os.path.exists(self._lib_PATH) == False:
        #     self._lib_PATH = os.path.dirname(os.path.abspath(__file__)) + "/libmytrpc.so"

    def __del__(self) :
        if self._handle>0 :
            self._rpc.closeDevice(self._handle)
    
    #è·å–SDK ç‰ˆæœ¬
    def get_sdk_version(self):
        ret = ''
        if os.path.exists(self._lib_PATH) == True:
            if sys.platform == "linux":
                dll = ctypes.CDLL(self._lib_PATH)
            else:
                dll = ctypes.WinDLL(self._lib_PATH)

            ret = dll.getVersion()
        return ret

    # åˆå§‹åŒ–
    def init(self, ip, port, timeout, max_retries=3):
        ret = False
        if os.path.exists(self._lib_PATH) == True:
            if sys.platform == "linux":
                self._rpc = ctypes.CDLL(self._lib_PATH)
            else:
                self._rpc = ctypes.WinDLL(self._lib_PATH)
            
            # ğŸ”§ å¢å¼ºé‡è¯•æœºåˆ¶ï¼šæœ€å¤šé‡è¯•5æ¬¡ï¼Œä½¿ç”¨æŒ‡æ•°é€€é¿
            max_retries = 5  # å¢åŠ é‡è¯•æ¬¡æ•°
            for retry_count in range(max_retries):
                logger.info(f"MytRpc init attempt {retry_count + 1}/{max_retries} for {ip}:{port}")
                
                # ğŸ”§ æ·»åŠ ç«¯å£è¿æ¥é¢„æ£€æŸ¥
                if retry_count > 0:
                    import socket
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(3)
                        result = sock.connect_ex((ip, port))
                        sock.close()
                        if result != 0:
                            logger.warning(f"MytRpc port {ip}:{port} pre-check failed (error: {result})")
                            # å¦‚æœç«¯å£æ— æ³•è¿æ¥ï¼Œç­‰å¾…æ›´é•¿æ—¶é—´
                            retry_delay = min(10 + retry_count * 5, 30)  # æœ€å¤šç­‰å¾…30ç§’
                            logger.info(f"Port unreachable, waiting {retry_delay}s before retry...")
                            time.sleep(retry_delay)
                            continue
                        else:
                            logger.info(f"MytRpc port {ip}:{port} pre-check passed")
                    except Exception as e:
                        logger.warning(f"MytRpc port pre-check exception: {e}")
                
                b_time = int(time.time())
                while True:
                    self._handle = self._rpc.openDevice(bytes(ip, "utf-8"), port, 10)
                    if self._handle > 0:
                        ret = True
                        logger.info(f"âœ… MytRpc {ip}:{port} connected successfully! (attempt {retry_count + 1})")
                        break
                    else:
                        now = int(time.time())
                        if now-b_time>timeout :
                            logger.warning(f"âŒ MytRpc {ip}:{port} timeout {timeout}s (attempt {retry_count + 1})")
                            break
                        else:
                            time.sleep(10)
                
                # å¦‚æœæˆåŠŸè¿æ¥ï¼Œè·³å‡ºé‡è¯•å¾ªç¯
                if ret:
                    break
                
                # å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡é‡è¯•ï¼Œä½¿ç”¨æŒ‡æ•°é€€é¿ç­‰å¾…
                if retry_count < max_retries - 1:
                    retry_delay = min(5 * (2 ** retry_count), 30)  # æŒ‡æ•°é€€é¿ï¼Œæœ€å¤š30ç§’
                    logger.warning(f"âŒ MytRpc init failed for {ip}:{port}, retrying in {retry_delay}s... (attempt {retry_count + 1}/{max_retries})")
                    time.sleep(retry_delay)
                else:
                    logger.error(f"âŒ MytRpc init failed for {ip}:{port} after {max_retries} attempts")
        else:
            logger.error("âŒ MytRpc library file not found: " + self._lib_PATH)
        return ret

    #æ£€æŸ¥è¿œç¨‹è¿æ¥æ˜¯å¦å¤„äºè¿æ¥çŠ¶æ€
    def check_connect_state(self):
        ret = False
        if self._handle>0:
            self._rpc.checkLive.argtypes = [ctypes.c_long]
            self._rpc.checkLive.restype = ctypes.c_int
            exec_ret = self._rpc.checkLive(self._handle)
            if exec_ret == 0:
                ret = False
            else:
                ret = True
        return ret
            #LIBMYTRPC_API int MYAPI checkLive(long handle);

    # æ‰§è¡Œå‘½ä»¤
    #è¿”å›çŠ¶æ€å€¼ å’Œ å†…å®¹
    def exec_cmd(self, cmd):
        ret = False
        out_put = ''
        if self._handle > 0:
            # cmd = " pm install /data/local/TikTok_26.5.3_apkcombo.com.apk"
            # cmd = "ls"
            self._rpc.execCmd.restype = ctypes.c_char_p
            ptr = self._rpc.execCmd(self._handle, ctypes.c_int(1), ctypes.c_char_p(cmd.encode('utf-8'))) 
            if ptr is not None:
                #if isinstance(ptr, str):
                out_put = ptr.decode('utf-8')
                logger.debug("exec " + cmd + "  :" + out_put)
                # else:
                ret = True
            else:
                ret = True
        return out_put, ret

    # å¯¼å‡ºèŠ‚ç‚¹ä¿¡æ¯
    # bDumpAll å¯¼å‡ºæ‰€æœ‰èŠ‚ç‚¹  0   1

    def dumpNodeXml(self, bDumpAll):
        """
        å¯¼å‡ºèŠ‚ç‚¹XMLä¿¡æ¯ã€‚

        å‚æ•°:
        - bDumpAll (bool): æ˜¯å¦å¯¼å‡ºæ‰€æœ‰ä¿¡æ¯ï¼ŒTrueè¡¨ç¤ºå¯¼å‡ºå…¨éƒ¨ï¼ŒFalseè¡¨ç¤ºä»…å¯¼å‡ºéƒ¨åˆ†ä¿¡æ¯ã€‚

        è¿”å›:
        - ret: æˆåŠŸæ—¶è¿”å›XMLå­—ç¬¦ä¸²ï¼Œå¤±è´¥æ—¶è¿”å›Falseã€‚
        """
        ret = False
        # ç¡®ä¿_handleæœ‰æ•ˆï¼Œä»¥é˜²æ­¢åœ¨æ— æ•ˆçš„çŠ¶æ€ä¸‹è°ƒç”¨RPCæ–¹æ³•
        if self._handle > 0:
            # è®¾ç½®RPCæ–¹æ³•dumpNodeXmlçš„å‚æ•°ç±»å‹å’Œè¿”å›ç±»å‹
            self._rpc.dumpNodeXml.argtypes = [ctypes.c_long, ctypes.c_int]
            self._rpc.dumpNodeXml.restype = ctypes.c_void_p
            # è°ƒç”¨RPCæ–¹æ³•dumpNodeXmlè·å–èŠ‚ç‚¹XMLä¿¡æ¯çš„æŒ‡é’ˆ
            ptr = self._rpc.dumpNodeXml(self._handle, bDumpAll)
            if ptr:
                # å°†æŒ‡é’ˆè½¬æ¢ä¸ºå­—ç¬¦ä¸²
                p2 = ctypes.cast(ptr, ctypes.c_char_p)
                ret = p2.value.decode("utf-8")
                # é‡Šæ”¾æŒ‡é’ˆå†…å­˜ï¼Œä»¥é˜²æ­¢å†…å­˜æ³„æ¼
                self._rpc.freeRpcPtr.argtypes = [ctypes.c_void_p]
                self._rpc.freeRpcPtr(ptr)
            else:
                # å½“è¿”å›çš„æŒ‡é’ˆä¸ºç©ºæ—¶ï¼Œè®°å½•è°ƒè¯•ä¿¡æ¯
                logger.debug('dumpNodeXml is NULL ptr!')
        return ret

    def dumpNodeXmlEx(self, workMode, timeout):
            """
            å¯¼å‡ºèŠ‚ç‚¹XMLä¿¡æ¯ã€‚

            å‚æ•°:
               workMode True  è¡¨ç¤ºå¼€å¯æ— éšœç¢  
                         False   è¡¨ç¤ºå…³é—­æ— éšœç¢ 
                timeout   è¶…æ—¶  å•ä½è±ªç§’(1ç§’=1000æ¯«ç§’)  -1 ä¸ºæ°¸ä¸è¶…æ—¶

            è¿”å›:
            - ret: æˆåŠŸæ—¶è¿”å›XMLå­—ç¬¦ä¸²ï¼Œå¤±è´¥æ—¶è¿”å›Falseã€‚
            åŸå‹
            LIBMYTRPC_API char* MYAPI dumpNodeXmlEx(long handle, int useNewMode, int timeout);
            """
            ret = False
            # ç¡®ä¿_handleæœ‰æ•ˆï¼Œä»¥é˜²æ­¢åœ¨æ— æ•ˆçš„çŠ¶æ€ä¸‹è°ƒç”¨RPCæ–¹æ³•
            if self._handle > 0:
                # è®¾ç½®RPCæ–¹æ³•dumpNodeXmlçš„å‚æ•°ç±»å‹å’Œè¿”å›ç±»å‹
                self._rpc.dumpNodeXmlEx.argtypes = [ctypes.c_long, ctypes.c_int, ctypes.c_int]
                self._rpc.dumpNodeXmlEx.restype = ctypes.c_void_p
                # è°ƒç”¨RPCæ–¹æ³•dumpNodeXmlè·å–èŠ‚ç‚¹XMLä¿¡æ¯çš„æŒ‡é’ˆ
                if workMode == True:
                    iMode = 1
                else:
                    iMode = 0
                ptr = self._rpc.dumpNodeXmlEx(self._handle, iMode, timeout)
                if ptr:
                    # å°†æŒ‡é’ˆè½¬æ¢ä¸ºå­—ç¬¦ä¸²
                    p2 = ctypes.cast(ptr, ctypes.c_char_p)
                    ret = p2.value.decode("utf-8")
                    # é‡Šæ”¾æŒ‡é’ˆå†…å­˜ï¼Œä»¥é˜²æ­¢å†…å­˜æ³„æ¼
                    self._rpc.freeRpcPtr.argtypes = [ctypes.c_void_p]
                    self._rpc.freeRpcPtr(ptr)
                else:
                    # å½“è¿”å›çš„æŒ‡é’ˆä¸ºç©ºæ—¶ï¼Œè®°å½•è°ƒè¯•ä¿¡æ¯
                    logger.debug('dumpNodeXmlEx is NULL ptr!')
            return ret

    # æˆªå›¾å¯¼å‡ºä¸ºbytes æ•°ç»„
    # type  0 png  1 jpg
    # quality  å›¾ç‰‡è´¨é‡  0-100
    # è¿”å›å­—èŠ‚æ•°ç»„
    def takeCaptrueCompress(self, type, quality):
        ret = False
        if self._handle > 0:
            dataLen = ctypes.c_int(0)
            self._rpc.takeCaptrueCompress.argtypes = [ctypes.c_long, ctypes.c_int, ctypes.c_int,  ctypes.POINTER(ctypes.c_int)]
            self._rpc.takeCaptrueCompress.restype = ctypes.c_void_p
            ptr = self._rpc.takeCaptrueCompress(self._handle, type, quality, ctypes.byref(dataLen))
            if ptr:
                try:
                    # å°†ptrè½¬æ¢ä¸ºbyteså¯¹è±¡
                    buf = ctypes.cast(ptr, ctypes.POINTER(ctypes.c_ubyte * dataLen.value)).contents
                    # ä½¿ç”¨OpenCVå°†byteså¯¹è±¡è½¬æ¢ä¸ºå›¾åƒ
                    ret = bytearray(buf)
                    # img_np = np.frombuffer(img_array, dtype=np.uint8)
                    # img = cv2.imdecode(img_np, cv2.IMREAD_COLOR)
                    # # æ˜¾ç¤ºå›¾åƒ
                    # cv2.imshow("Image", img)
                    # cv2.waitKey(0)
                finally:
                    # é‡Šæ”¾æŒ‡é’ˆå†…å­˜
                    self._rpc.freeRpcPtr.argtypes = [ctypes.c_void_p]
                    self._rpc.freeRpcPtr(ptr)
        return ret
    
    #æŒ‡å®šåŒºåŸŸæˆªå›¾
    def takeCaptrueCompressEx(self, left, top, right, bottom, type, quality):
        ret = False
        if self._handle > 0:
            dataLen = ctypes.c_int(0)
            self._rpc.takeCaptrueCompressEx.argtypes = [ctypes.c_long, ctypes.c_int, ctypes.c_int,ctypes.c_int, ctypes.c_int,ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int)]
            self._rpc.takeCaptrueCompressEx.restype = ctypes.c_void_p
            ptr = self._rpc.takeCaptrueCompressEx(self._handle, left, top,right, bottom, type, quality, ctypes.byref(dataLen))
            if ptr:
                try:
                    # å°†ptrè½¬æ¢ä¸ºbyteså¯¹è±¡
                    buf = ctypes.cast(ptr, ctypes.POINTER(ctypes.c_ubyte * dataLen.value)).contents
                    # ä½¿ç”¨OpenCVå°†byteså¯¹è±¡è½¬æ¢ä¸ºå›¾åƒ
                    ret = bytearray(buf)
                    # img_np = np.frombuffer(img_array, dtype=np.uint8)
                    # img = cv2.imdecode(img_np, cv2.IMREAD_COLOR)
                    # # æ˜¾ç¤ºå›¾åƒ
                    # cv2.imshow("Image", img)
                    # cv2.waitKey(0)
                finally:
                    # é‡Šæ”¾æŒ‡é’ˆå†…å­˜
                    self._rpc.freeRpcPtr.argtypes = [ctypes.c_void_p]
                    self._rpc.freeRpcPtr(ptr)
            else:
                logger.debug(f"takeCaptrueCompressEx error {ptr}")
        return ret
    
    
    #æˆªå›¾åˆ°æ–‡ä»¶
    def screentshotEx(self,left, top, right, bottom, type, quality, file_path):
        ret = False
        byte_data = self.takeCaptrueCompressEx(left, top, right, bottom,type, quality) 
        if byte_data != False:
            with open(file_path, 'wb') as file:
                file.write(byte_data)
            ret = True
        else:
            logger.debug("screentshotEx error")
        return ret

    #æˆªå›¾åˆ°æ–‡ä»¶
    def screentshot(self, type, quality, file_path):
        ret = False
        byte_data = self.takeCaptrueCompress(type, quality) 
        if byte_data != False:
            with open(file_path, 'wb') as file:
                file.write(byte_data)
            ret = True
        return ret

    # æ–‡å­—è¾“å…¥
    def sendText(self, text):
        ret = False
        if self._handle > 0:
            exec_ret =  self._rpc.sendText(self._handle, ctypes.c_char_p(text.encode('utf-8')))
            if exec_ret == 1:
                ret = True
        return ret

    #æ¸…é™¤è¾“å…¥çš„æ–‡å­—
    def ClearText(self, count):
        for i in range(0, count):
            self.keyPress(67)
        


    # å¼€å¯æŒ‡å®šçš„åº”ç”¨
    def openApp(self, pkg):
        ret = False
        if self._handle > 0:
            exec_ret = self._rpc.openApp(self._handle, ctypes.c_char_p(pkg.encode('utf-8')))
            if exec_ret == 1:
                ret = True
        return ret

    #åœæ­¢æŒ‡å®šçš„åº”ç”¨
    def stopApp(self, pkg):
        ret = False
        if self._handle > 0:
            exec_ret = self._rpc.stopApp(self._handle, ctypes.c_char_p(pkg.encode('utf-8')))
            if exec_ret == 1:
                ret = True
        return ret

    #è·å–å½“å‰å±å¹•çš„æ–¹å‘
    #  4ä¸ªæ–¹å‘ï¼ˆ0,1,2,3ï¼‰
    def getDisplayRotate(self):
        ret = False
        if self._handle > 0:
            if self._rpc.getDisplayRotate(self._handle) == 1:
                ret = True
        return ret
    
    #æŒ‰ä¸‹æ“ä½œ
    def touchDown(self, finger_id, x, y):
        ret = False
        if self._handle > 0:
            if self._rpc.touchDown(self._handle, finger_id, x, y) == 1:
                ret = True
        return ret
    
    #å¼¹èµ·æ“ä½œ
    def touchUp(self, finger_id, x, y):
        ret = False
        if self._handle > 0:
            if self._rpc.touchUp(self._handle, finger_id, x, y) == 1:
                ret = True
        return ret
    
    #æ»‘åŠ¨æ“ä½œ
    def touchMove(self, finger_id, x, y):
        ret = False
        if self._handle > 0:
            if self._rpc.touchMove(self._handle, finger_id, x, y) == 1:
                ret = True
        return ret
    
    #å•å‡»æ“ä½œ
    def touchClick(self, finger_id, x, y):
        ret = False
        if self._handle > 0:
            if self._rpc.touchClick(self._handle, finger_id, x, y) == 1:
                ret = True
        return ret

    #é•¿æŒ‰æ“ä½œ
    #t ä¸ºé•¿æŒ‰çš„æ—¶é•¿  å•ä½: ç§’(float)
    def longClick(self, finger_id, x, y, t):
        ret = False
        if self._handle>0:
            if self._rpc.touchDown(self._handle, finger_id, x, y) > 0:
                time.sleep(t)
                exec_ret = self._rpc.touchUp(self._handle, finger_id, x, y)
                if exec_ret ==1 :
                    ret = True
        return ret

    #æŒ‰é”®æ“ä½œ
    # é”®å€¼ å‚è€ƒ: https://blog.csdn.net/yaoyaozaiye/article/details/122826340
    def keyPress(self, code):
        ret = False
        if self._handle > 0:
            if self._rpc.keyPress(self._handle, code) == 1:
                ret = True
        return ret
    
    #BackæŒ‰é”®
    def pressBack(self):
        return self.keyPress(4)
    
    #Enter æŒ‰é”®
    def pressEnter(self):
        return self.keyPress(66)
    
    #Home æŒ‰é”®
    def pressHome(self):
        return self.keyPress(3)
    
    #Menu æŒ‰é”®
    def pressRecent(self):
        return self.keyPress(82)

    #æ»‘åŠ¨æ“ä½œ
    # x0 y0 èµ·å§‹åæ ‡
    # x1 y1 ç»ˆç‚¹åæ ‡
    # elapse æ—¶é•¿  (å•ä½:æ¯«ç§’)   
    def swipe(self, id, x0, y0, x1, y1, elapse):
        ret = False
        if self._handle>0:
            ret = self._rpc.swipe(self._handle,id,  x0, y0, x1, y1, elapse, False)
        return ret
    
    #åˆ›å»ºselectorç­›é€‰å™¨å¯¹è±¡
    def create_selector(self):
        ret = None
        if self._handle>0:
            ret = mytSelector(self._handle, self._rpc)
        return ret
    
    #é‡Šæ”¾ selector å¯¹è±¡
    def release_selector(self, sel):
        del sel
    
    #æŒ‰ç…§Nodeçš„å±æ€§æ‰§è¡Œç‚¹å‡»
    def clickText(self, text):
        ret = False
        selector = self.create_selector() 
        selector.addQuery_TextEqual(text)
        node = selector.execQueryOne(200)
        if node is not None:
            ret = node.Click_events()
        self.release_selector(selector)
        return ret

    def clickTextMatchStart(self, text):
        ret = False
        selector = self.create_selector()
        selector.addQuery_TextStartWith(text)
        node = selector.execQueryOne(200)
        if node is not None:
            ret = node.Click_events()
        self.release_selector(selector)
        return ret
        
    def clickClass(self, clzName):
        ret = False
        selector = self.create_selector() 
        selector.addQuery_ClzEqual(clzName)
        node = selector.execQueryOne(200)
        if node is not None:
            ret = node.Click_events()
        self.release_selector(selector)
        return ret
    
    def clickId(self, id):
        ret = False
        selector = self.create_selector() 
        selector.addQuery_IdEqual(id)
        node = selector.execQueryOne(200)
        if node is not None:
            ret = node.Click_events()
        self.release_selector(selector)
        return ret
    
    def clickDesc(self, des):
        ret = False
        selector = self.create_selector() 
        selector.addQuery_DescEqual(des)
        node = selector.execQueryOne(200)
        if node is not None:
            ret = node.Click_events()
        self.release_selector(selector)
        return ret

    #ä¾æ®Text è·å–NodeèŠ‚ç‚¹
    def getNodeByText(self, text):
        ret  = None
        selector = self.create_selector() 
        selector.addQuery_TextEqual(text)
        node_arr = selector.execQuery(999,200)
        if len(node_arr)>0 :
            arr = []
            for n in node_arr:
                json_str = n.getNodeJson()
                json_obj = json.loads(json_str)
                arr.append(json_obj)
            ret = json.dumps(arr)
        self.release_selector(selector)
        return ret

    def getNodeByTextMatchEnd(self, text):
        ret  = None
        selector = self.create_selector()
        selector.addQuery_TextEndWith(text)
        node_arr = selector.execQuery(999,200)
        if len(node_arr)>0 :
            arr = []
            for n in node_arr:
                json_str = n.getNodeJson()
                json_obj = json.loads(json_str)
                arr.append(json_obj)
            ret = json.dumps(arr)
        self.release_selector(selector)
        return ret

    def getNodeByTextMatchStart(self, text):
        ret  = None
        selector = self.create_selector()
        selector.addQuery_TextStartWith(text)
        node_arr = selector.execQuery(999,200)
        if len(node_arr)>0 :
            arr = []
            for n in node_arr:
                json_str = n.getNodeJson()
                json_obj = json.loads(json_str)
                arr.append(json_obj)
            ret = json.dumps(arr)
        self.release_selector(selector)
        return ret

    #æ ¹æ®pkg è·å–NodeèŠ‚ç‚¹
    def getNodeByPkg(self,pkg):
        ret = None
        selector = self.create_selector()
        selector.addQuery_PackageEqual(pkg)
        node_arr = selector.execQuery(999, 200)
        if len(node_arr) > 0:
            arr = []
            for n in node_arr:
                json_str = n.getNodeJson()
                json_obj = json.loads(json_str)
                arr.append(json_obj)
            ret = json.dumps(arr)
        self.release_selector(selector)
        return ret

    def getNodeByClass(self, clzName):
        ret  = None
        selector = self.create_selector() 
        selector.addQuery_ClzEqual(clzName)
        node_arr = selector.execQuery(999,200)
        if len(node_arr)>0 :
            arr = []
            for n in node_arr:
                json_str = n.getNodeJson()
                json_obj = json.loads(json_str)
                arr.append(json_obj)
            ret = json.dumps(arr)
        self.release_selector(selector)
        return ret

    def getNodeById(self, id):
        ret  = None
        selector = self.create_selector() 
        selector.addQuery_IdEqual(id)
        node_arr = selector.execQuery(999,200)
        if len(node_arr)>0 :
            arr = []
            for n in node_arr:
                json_str = n.getNodeJson()
                json_obj = json.loads(json_str)
                arr.append(json_obj)
            ret = json.dumps(arr)
        self.release_selector(selector)
        return ret
    
    def getNodeByDesc(self, desc):
        ret  = None
        selector = self.create_selector() 
        selector.addQuery_DescEqual(desc)
        node_arr = selector.execQuery(999,200)
        if len(node_arr)>0 :
            arr = []
            for n in node_arr:
                json_str = n.getNodeJson()
                json_obj = json.loads(json_str)
                arr.append(json_obj)
            ret = json.dumps(arr)
        self.release_selector(selector)
        return ret
    
    #è®¾ç½®rpa çš„å·¥ä½œæ¨¡å¼     1   è¡¨ç¤ºå¼€å¯æ— éšœç¢  ï¼ˆé»˜è®¤çš„å·¥ä½œæ¨¡å¼ï¼‰   
    #                      0   è¡¨ç¤ºå…³é—­æ— éšœç¢ 
    # è®¾ç½®RPAå·¥ä½œæ¨¡å¼
    # æœ¬å‡½æ•°ç”¨äºè®¾ç½®RPAçš„å·¥ä½œæ¨¡å¼ï¼Œä¸»è¦æ˜¯ä¸ºäº†ç¡®å®šæ˜¯å¦ä½¿ç”¨æ— éšœç¢æ¨¡å¼
    # å¼€å¯æ— éšœç¢æ¨¡å¼åï¼Œå¯ä»¥è·å–æ›´åŠ å®Œæ•´çš„èŠ‚ç‚¹ä¿¡æ¯ï¼Œä½†æŸäº›åº”ç”¨ç¯å¢ƒä¼šæ£€æµ‹æ˜¯å¦å¼€å¯äº†æ— éšœç¢
    # è¯¥æ–¹æ³•éœ€è¦ æœ€æ–°çš„é¢å›ºä»¶ç‰ˆæœ¬æ”¯æŒ  
    # å‚æ•°:
    #   mode: å·¥ä½œæ¨¡å¼çš„è®¾ç½®å€¼ï¼Œå†³å®šæ˜¯å¦ä½¿ç”¨æ— éšœç¢æ¨¡å¼
    # è¿”å›å€¼:
    #   æˆåŠŸè®¾ç½®è¿”å›Trueï¼Œå¦åˆ™è¿”å›False
    def setRpaWorkMode(self, mode):
        # åˆå§‹åŒ–è¿”å›å€¼ä¸ºFalse
        ret = False
        # æ£€æŸ¥_handleæ˜¯å¦æœ‰æ•ˆ
        if self._handle>0:
            # è®¾ç½®useNewNodeModeå‡½æ•°çš„å‚æ•°ç±»å‹
            self._rpc.useNewNodeMode.argtypes = [ctypes.c_long, ctypes.c_int]
            # è®¾ç½®useNewNodeModeå‡½æ•°çš„è¿”å›ç±»å‹
            self._rpc.useNewNodeMode.restype = ctypes.c_int
            # è°ƒç”¨useNewNodeModeå‡½æ•°ï¼Œå¹¶ä¼ å…¥_handleå’Œmodeå‚æ•°
            exec_ret = self._rpc.useNewNodeMode(self._handle, mode)
            # æ ¹æ®å‡½æ•°æ‰§è¡Œç»“æœè®¾ç½®è¿”å›å€¼
            if exec_ret == 0:
                ret = False
            else:
                ret = True
        # è¿”å›è®¾ç½®ç»“æœ
        return ret

    def startVideoStream(self):
        """
        å¯åŠ¨è§†é¢‘æµã€‚

        åœ¨è°ƒç”¨æ­¤æ–¹æ³•ä¹‹å‰ï¼Œéœ€è¦ç¡®ä¿å·²ç»æˆåŠŸè¿æ¥åˆ°è®¾å¤‡ï¼Œå¹¶ä¸”_handleæ˜¯æœ‰æ•ˆçš„ã€‚
        è¯¥æ–¹æ³•å°†æ ¹æ®æŒ‡å®šçš„å‚æ•°ï¼ˆåˆ†è¾¨ç‡å’Œæ¯”ç‰¹ç‡ï¼‰å¯åŠ¨è§†é¢‘æµï¼Œå¹¶æ³¨å†Œå›è°ƒå‡½æ•°ä»¥å¤„ç†è§†é¢‘å’ŒéŸ³é¢‘æ•°æ®ã€‚
        
        video_cb è§†é¢‘å›è°ƒå‡½æ•°
        audio_cb éŸ³é¢‘å›è°ƒå‡½æ•°
        Returns:
            bool: å¦‚æœè§†é¢‘æµæˆåŠŸå¯åŠ¨å¹¶è¿è¡Œï¼Œåˆ™è¿”å›Trueï¼›å¦åˆ™è¿”å›Falseã€‚
        """
        # æ£€æŸ¥_handleæ˜¯å¦æœ‰æ•ˆ
        if self._handle > 0:
            # é…ç½®startVideoStreamçš„å‚æ•°ç±»å‹
            self._rpc.startVideoStream.argtypes = [ctypes.c_long,
                                                ctypes.c_int,
                                                ctypes.c_int,
                                                ctypes.c_int,
                                                CB_FUNC,
                                                AUDIO_CB_FUNC
                                                ]
            # è®¾ç½®startVideoStreamçš„è¿”å›ç±»å‹
            self._rpc.startVideoStream.restype = ctypes.c_int

            # è°ƒç”¨ startVideoStream å‡½æ•°
            w = 400
            h = 720
            bitrate = 1000 * 20
            exec_ret = self._rpc.startVideoStream(self._handle, w, h, bitrate, video_cb, audio_cb)
            if exec_ret == 1:
                # å¦‚æœè§†é¢‘æµæˆåŠŸå¯åŠ¨ï¼Œè¿›å…¥å¾ªç¯ä»¥æŒç»­è¿è¡Œ
                while True:
                    time.sleep(1)
                    print('is running')
            else:
                # å¦‚æœè§†é¢‘æµå¯åŠ¨å¤±è´¥ï¼Œè®¾ç½®è¿”å›å€¼ä¸ºFalse
                ret = False
        else:
            # å¦‚æœ_handleæ— æ•ˆï¼Œè®¾ç½®è¿”å›å€¼ä¸ºFalse
            ret = False
        # è¿”å›è§†é¢‘æµçš„è¿è¡ŒçŠ¶æ€
        return ret
